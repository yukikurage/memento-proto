module Language.Memento.TypeSolver.Inference where

import qualified Data.Map.Strict as Map
import qualified Data.Set as Set
import qualified Data.Text as T
import Control.Monad.State
import Language.Memento.Syntax
import Language.Memento.Syntax.Expr (Expr(..), Let(..))
import qualified Language.Memento.Syntax.MType as SMType
import qualified Language.Memento.Syntax.Literal as SLiteral
import qualified Language.Memento.Syntax.Variable as SVariable
import qualified Language.Memento.Syntax.Pattern as SPattern
import qualified Language.Memento.Syntax.Definition as SDefinition
import qualified Language.Memento.Syntax.Program as SProgram
import qualified Language.Memento.Syntax.BinOp as SBinOp
import Language.Memento.Syntax.Tag (KType, KExpr, KLiteral, KVariable, KPattern, KDefinition, KProgram, KLet, KBinOp)
import Language.Memento.Data.HFix (HFix(..), unHFix)
import Language.Memento.TypeSolver.Types
import Language.Memento.TypeSolver.Solver

-- Type inference context
data InferContext = InferContext
  { icVarCounter :: Int
  , icConstraints :: ConstraintSet
  , icTypeEnv :: Map.Map T.Text Type
  } deriving (Show)

type InferM = State InferContext

-- Generate fresh type variable
freshVar :: InferM TypeVar
freshVar = do
  ctx <- get
  let counter = icVarCounter ctx
  put ctx { icVarCounter = counter + 1 }
  return $ TypeVar $ T.pack ("t" ++ show counter)

-- Add constraint
addConstraint :: Constraint -> InferM ()
addConstraint c = do
  ctx <- get
  put ctx { icConstraints = Set.insert c (icConstraints ctx) }

-- Look up variable type
lookupVar :: T.Text -> InferM (Maybe Type)
lookupVar name = do
  ctx <- get
  return $ Map.lookup name (icTypeEnv ctx)

-- Add variable to environment
addVar :: T.Text -> Type -> InferM ()
addVar name typ = do
  ctx <- get
  put ctx { icTypeEnv = Map.insert name typ (icTypeEnv ctx) }

-- Convert Memento MType to solver Type
convertMType :: AST KType -> Type
convertMType ast = 
  case unMType $ extractSyntax $ unHFix ast of
    SMType.TNumber -> TNumber
    SMType.TBool -> TBool
    SMType.TString -> TString
    SMType.TNever -> TNever
    SMType.TUnknown -> TUnknown
    SMType.TVar varAst -> 
      let SVariable.Var name = unVariable $ extractSyntax $ unHFix varAst
      in TVar (TypeVar name)
    SMType.TLiteral litAst -> 
      convertLiteral litAst
    SMType.TFunction params retType -> 
      let paramTypes = map (convertMType . snd) params
          returnType = convertMType retType
      in foldr TFunction returnType paramTypes
    SMType.TUnion types -> 
      mkUnion (map convertMType types)
    SMType.TIntersection types -> 
      mkIntersection (map convertMType types)
  where
    extractSyntax (metadata, syntax) = syntax

-- Convert literal to solver type
convertLiteral :: AST KLiteral -> Type
convertLiteral ast = 
  case unLiteral $ extractSyntax $ unHFix ast of
    SLiteral.NumberLiteral n -> TLiteral (LNumber n)
    SLiteral.BoolLiteral b -> TLiteral (LBool b)
    SLiteral.StringLiteral s -> TLiteral (LString s)
    SLiteral.IntLiteral i -> TLiteral (LNumber (fromIntegral i))
  where
    extractSyntax (metadata, syntax) = syntax

-- Infer type for expressions
inferExpr :: AST KExpr -> InferM Type
inferExpr ast = 
  case unExpr $ extractSyntax $ unHFix ast of
    EVar varAst -> do
      let SVariable.Var name = unVariable $ extractSyntax $ unHFix varAst
      maybeType <- lookupVar name
      case maybeType of
        Just t -> return t
        Nothing -> do
          freshType <- TVar <$> freshVar
          addVar name freshType
          return freshType
    
    ELiteral litAst -> return $ convertLiteral litAst
    
    ELambda params bodyAst -> do
      paramTypes <- mapM (\(patAst, typeAst) -> do
        paramType <- convertMType typeAst
        case unPattern $ extractSyntax $ unHFix patAst of
          SPattern.PVar varAst -> do
            let SVariable.Var name = unVariable $ extractSyntax $ unHFix varAst
            addVar name paramType
            return paramType
          _ -> error "Complex patterns not yet supported in lambda"
        ) params
      bodyType <- inferExpr bodyAst
      return $ foldr TFunction bodyType paramTypes
    
    EApply funcAst argAsts -> do
      funcType <- inferExpr funcAst
      argTypes <- mapM inferExpr argAsts
      resultType <- TVar <$> freshVar
      let expectedType = foldr TFunction resultType argTypes
      addConstraint $ Subtype funcType expectedType
      return resultType
    
    EIf condAst thenAst elseAst -> do
      condType <- inferExpr condAst
      addConstraint $ Subtype condType TBool
      thenType <- inferExpr thenAst
      elseType <- inferExpr elseAst
      resultType <- TVar <$> freshVar
      addConstraint $ Subtype thenType resultType
      addConstraint $ Subtype elseType resultType
      return resultType
    
    EBinOp opAst leftAst rightAst -> do
      leftType <- inferExpr leftAst
      rightType <- inferExpr rightAst
      case unBinOp $ extractSyntax $ unHFix opAst of
        SBinOp.Add -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TNumber
        SBinOp.Sub -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TNumber
        SBinOp.Mul -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TNumber
        SBinOp.Div -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TNumber
        SBinOp.Eq -> do
          unifiedType <- TVar <$> freshVar
          addConstraint $ Subtype leftType unifiedType
          addConstraint $ Subtype rightType unifiedType
          return TBool
        SBinOp.Lt -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TBool
        SBinOp.Gt -> do
          addConstraint $ Subtype leftType TNumber
          addConstraint $ Subtype rightType TNumber
          return TBool
    
    EBlock letAsts exprAst -> do
      mapM_ (\letAst -> 
        case unLet $ extractSyntax $ unHFix letAst of
          Let patAst typeAst exprAst -> do
            exprType <- inferExpr exprAst
            declaredType <- convertMType typeAst
            addConstraint $ Subtype exprType declaredType
            case unPattern $ extractSyntax $ unHFix patAst of
              SPattern.PVar varAst -> do
                let SVariable.Var name = unVariable $ extractSyntax $ unHFix varAst
                addVar name declaredType
              _ -> error "Complex patterns not yet supported in let"
        ) letAsts
      inferExpr exprAst
    
    EMatch _ _ -> error "Pattern matching not yet implemented"
  where
    extractSyntax (metadata, syntax) = syntax

-- Infer type for value declarations  
inferValueDecl :: T.Text -> AST KType -> AST KExpr -> InferM Type
inferValueDecl name typeAst exprAst = do
  declaredType <- convertMType typeAst
  inferredType <- inferExpr exprAst
  addConstraint $ Subtype inferredType declaredType
  addVar name declaredType
  return declaredType

-- Main inference function
inferProgram :: AST KProgram -> Either String (Map.Map T.Text Type)
inferProgram ast = 
  let initialCtx = InferContext 0 Set.empty Map.empty
      ((), finalCtx) = runState (inferProgramM ast) initialCtx
      constraints = icConstraints finalCtx
  in case solveConstraints constraints of
    Success subst -> 
      let finalEnv = Map.map (applySubst subst) (icTypeEnv finalCtx)
      in Right finalEnv
    Contradiction -> Left "Type error: contradictory constraints"
    Ambiguous _ -> Left "Type error: ambiguous types"

inferProgramM :: AST KProgram -> InferM ()
inferProgramM ast = 
  case unProgram $ extractSyntax $ unHFix ast of
    SProgram.Program declAsts -> mapM_ inferDecl declAsts
  where
    extractSyntax (metadata, syntax) = syntax

inferDecl :: AST KDefinition -> InferM ()
inferDecl ast = 
  case unDefinition $ extractSyntax $ unHFix ast of
    SDefinition.ValDef varAst typeAst exprAst -> do
      let SVariable.Var name = unVariable $ extractSyntax $ unHFix varAst
      _ <- inferValueDecl name typeAst exprAst
      return ()
    SDefinition.DataDef _ _ -> return () -- Data definitions handled separately
    SDefinition.TypeDef _ _ -> return () -- Type aliases handled separately
  where
    extractSyntax (metadata, syntax) = syntax

-- Type checking interface
typeCheck :: AST KProgram -> Either String (Map.Map T.Text Type)
typeCheck = inferProgram