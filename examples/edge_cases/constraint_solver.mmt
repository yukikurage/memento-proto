// Edge cases for constraint solver

// Edge Case 1: Type variable unification
val f : (x : number) => number := (x : number) => x;
val test1 : number := f(42);

// Edge Case 2: Subtype constraints with literals
val identity<T> : (x : T) => T := (x : T) => x;
val test2 : number := identity(42);  // TLiteral(42) <: TVar <: TNumber

// Edge Case 3: Function subtyping
val g : (x : number) => number := (x : number) => x + 1;
val h : (x : number) => number := g;  // Function assignment

// Edge Case 4: Union type constraints (if supported)
// val union_test : number := if(true) { 42 } else { 1 };

// Edge Case 5: Nested function calls
val add : (x : number, y : number) => number := (x : number, y : number) => x + y;
val test5 : number := add(1, 2);

// Edge Case 6: Higher-order function constraints
val twice : (f : (x : number) => number, x : number) => number :=
  (f : (x : number) => number, x : number) => f(f(x));
val inc : (x : number) => number := (x : number) => x + 1;
val test6 : number := twice(inc, 5);
