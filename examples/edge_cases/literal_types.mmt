// Edge cases for literal types (singleton types: 42 : 42, "hello" : "hello")

// Edge Case 1: Singleton literal types with polymorphic identity
val identity<T> : (x : T) => T := (x : T) => x;
val num_literal : number := identity(42);        // 42 : 42 -> number
val string_literal : string := identity("hello"); // "hello" : "hello" -> string
val bool_literal : bool := identity(true);       // true : true -> bool

// Edge Case 2: Literal type constraints
val specific_number : number := 42;  // 42 : 42 <: number
val specific_string : string := "test"; // "test" : "test" <: string

// Edge Case 3: Literal types in function signatures
val add_one_to_literal : number := (x : number) => x + 1;
val test_literal_func : number := add_one_to_literal(42);

// Edge Case 4: Mixed literal and base types
val mixed_ops : number := 42 + 1;  // 42 : 42 + 1 : 1 = number
val string_concat : string := "hello" + "world";

// Edge Case 5: Literal type widening in conditions
val conditional : number := if(true) { 42 } else { 1 }; // Should be number, not union

// Edge Case 6: Literal types with arithmetic
val arithmetic1 : number := 40 + 2;  // Should resolve to number
val arithmetic2 : number := 10 * 4;
val arithmetic3 : number := 50 - 8;