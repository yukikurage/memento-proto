// Example demonstrating custom effect operations (a simplified State-like effect)

data Pair [
  MkPair: number -> number -> Pair // To store final state and result
];

// Define a State-like effect
effect MyState [
  Get: number -> number, // Get takes a dummy arg, returns current state
  Put: number -> number  // Put takes new state, returns dummy old state (or new state)
];

// A computation using Get and Put
// Takes an initial value, adds current state to it, puts new state, returns sum.
val stateful_comp : (number -> number with <MyState>) := initial_arg -> (
  (do Get) 0 |> current_state -> // 0 is a dummy arg for Get
  (do Put) (current_state + initial_arg) |> _ -> // Put new state (current + initial_arg)
  (current_state + initial_arg) // Return the sum
);

// Handler for MyState effect
// Takes an initial state and a computation (number -> number with <MyState>)
// Returns a Pair of (final_state, result_of_computation)
val run_state_handler : (number -> (number -> number with <MyState>) -> Pair) := initial_state -> comp ->
  handle <MyState> (comp 0) [ // Pass a dummy 0 to comp, real initial val for comp is not used here.
                                 // The 'comp' itself is 'stateful_comp' which takes an initial_arg.
                                 // Let's adjust how 'comp' is called or defined.
                                 // For this example, let's assume comp doesn't take an external arg,
                                 // or the handler passes one.
                                 // The example `stateful_comp` above takes `initial_arg`.
                                 // So, `handle <MyState> (stateful_comp 10) [...]` is better.

    // This handler needs to manage the state.
    // The state is passed via the continuation 'k'.
    // This is not a standard state monad handler which typically has a state argument threaded through.
    // Memento's handlers pass the "rest of the computation" as 'k'.
    // To simulate a state monad, the state needs to be part of the return type of 'k'
    // or the handler itself needs to be structured differently, perhaps recursively.

    // Let's simplify for a direct handler demonstration, where 'k' implicitly carries the state.
    // This requires the type of 'k' in Get/Put to be (state_type -> result_type_with_effect),
    // and the handler manipulates this.
    // The current handler structure: (Op arg to k) -> body. 'k' is (op_ret_type -> final_handler_ret_type with outer_effects).

    // A more direct way to handle state with this handler structure is to make the handler
    // itself a function that takes the current state.
    // e.g. val run_state_internal : (number/*state*/ -> number/*comp_result*/ with <MyState> -> Pair)
    // This gets complicated quickly.

    // Let's use a simpler interpretation for this example, focusing on op interception:
    // We'll have a fixed "state" for this example run, managed externally to the handler for simplicity.
    // This is NOT a full state monad, just showing op handling.

    // To make it runnable with the current handler semantics, we'll assume the handler
    // transforms the computation into one that takes the state explicitly.
    // This is what a real state handler would do, but it's complex to express here.

    // Let's redefine `run_state_handler` and the computation to be more like a transformation.
    // The handler will manage the state for the duration of the handled computation.
    // This example becomes more about "running" a stateful computation.

    // Simplified: The handler will take an initial state.
    // Get will return it. Put will update it FOR THE NEXT OPERATION via 'k'.
    // This is tricky because 'k' represents the *rest of the original computation*,
    // not the rest of the handler.

    // Re-think: The example from the prompt for `Trans` effect: `(NumBool n to k) -> (n > 0) |> k`.
    // `k` is `bool -> result_type_of_handle_body with outer_effects`.
    // If `k` needs to carry state, its type would be `bool -> (state -> result_type_of_handle_body with outer_effects)`.
    // And the handler would need to be invoked with an initial state.

    // Given the limitations, let's make a handler that *simulates* running with an initial state.
    // This means the handler's clauses will need to be clever.

    // This simplified example will provide a fixed state when Get is called,
    // and simply log Puts, then continue. Not a true state monad.

    (Get dummy_arg to k) -> ( (12345) |> k ), // Always return 12345 as state, k : (number -> result with <MyState>)

    (Put new_val to k) -> ( (new_val) |> k ), // Acknowledge put, pass new_val to k (k : number -> result with <MyState>)
                                          // This isn't updating state for next Get, just for continuation of current op.

    val_x -> ( (MkPair 0 val_x) ) // Dummy final state 0, val_x is result of comp.
                                 // This needs `initial_state` to be part of final state.
                                 // The issue is how to thread state.
];

// A version of run_state_handler that attempts to thread state.
// This would require the continuations (k) to also pass state.
// (Op arg to k_op) -> handler_body. k_op : (op_ret_type -> final_handler_type)
// If final_handler_type is (state -> Pair), then k_op : (op_ret_type -> (state -> Pair)).
// The handler body must then call k_op with a value and then provide the next state.
// e.g. (k_op op_result_val) next_state_val

// Let's use a more common pattern for state handlers if possible, or simplify.
// The standard way is that the handler function takes the state:
// `val runMyState : (S -> (alpha with <MyState>) -> (S, alpha))`
// `runMyState s comp = handle comp [ (Get dummy to k) -> runMyState s (k s), ... ]` - this is recursive.

// For a non-recursive handler, let's assume the state is managed by the handler's closure,
// which is not directly possible with Memento's current `val` syntax.

// Back to a simpler, testable example for custom ops Get/Put:
// The handler will take an initial state.
// Get returns this initial state.
// Put updates a "shadow" state that this specific handler instance sees for *itself* (not really).
// This is still not right.

// Correct approach for this example, focusing on the handler intercepting ops:
// The handler will take an initial state.
// It will then "run" the computation.
// If Get is called, the handler provides the current state and continues the computation with that state.
// If Put is called, the handler updates its state and continues the computation.
// The continuation `k` is key.
// (Get _ to k) -> let current_s = ... in k current_s
// (Put new_s to k) -> let _ = ... (update state) in k new_s (or dummy)

// This implies the handler itself needs to be a loop or recursive function that carries state.
// `val loop : S -> (A with <E>) -> (S, A)`
// `loop s expr = handle expr [ (Op x k) -> loop (s') (k y), ret_val -> (s, ret_val) ]`

// Given the simple `handle` syntax, we cannot easily write a recursive state-carrying handler directly.
// So, `effect_custom_ops.mmt` will demonstrate a handler that substitutes fixed values for operations.

val my_computation_uses_state : (number -> number with <MyState>) := dummy_arg -> (
  (do Get) dummy_arg |> val_from_get ->       // val_from_get should be 100
  (do Put) (val_from_get + 5) |> val_from_put -> // val_from_put should be 105
  (val_from_get + val_from_put)             // Expect 100 + 105 = 205
);

// Handler that provides fixed behavior for Get/Put
val run_with_fixed_state_logic : ( (number -> number with <MyState>) -> number) := comp_arg ->
  handle <MyState> (comp_arg 0) [ // Pass dummy 0 to comp_arg
    (Get _ to k) -> ( (100) |> k ),        // When Get is called, provide 100 to continuation k
                                         // k : (number -> number with <MyState>) -> number
    (Put val_to_put to k) -> ( (val_to_put) |> k ), // When Put is called, pass val_to_put to k
                                                 // k : (number -> number with <MyState>) -> number
    val_result -> val_result                 // The final result of the computation
  ];

// Execute it
val final_custom_op_example_result : number := (run_with_fixed_state_logic my_computation_uses_state);
// Expected:
// 1. my_computation_uses_state(0) is called.
// 2. (do Get) 0 occurs.
// 3. Handler catches Get. k is `val_from_get -> ((do Put) (val_from_get + 5) |> val_from_put -> (val_from_get + val_from_put))`.
// 4. Handler executes `(100) |> k`. So, `k` is called with `val_from_get = 100`.
// 5. Inside k: `(do Put) (100 + 5)` which is `(do Put) 105`. This occurs.
// 6. Handler catches Put with `val_to_put = 105`. k_put is `val_from_put -> (100 + val_from_put)`.
// 7. Handler executes `(105) |> k_put`. So, `k_put` is called with `val_from_put = 105`.
// 8. Inside k_put: `(100 + 105)` which is `205`. This is a value.
// 9. This value `205` becomes `val_result` in the handler's return clause.
// 10. Handler returns `205`.
// So, `final_custom_op_example_result` should be 205.

val another_comp : (number -> number with <MyState>) := _ -> (
  (do Get) 0 |> v1 -> // v1 = 100
  (do Get) 0 |> v2 -> // v2 = 100 (because Get handler always returns 100)
  (v1 + v2)         // Expect 100 + 100 = 200
);
val result_another_comp : number := (run_with_fixed_state_logic another_comp); // Expected 200.
