// Test case to demonstrate pattern bounds and exhaustivity checking

// Define some types
data MyInt : (value : number) => MyInt;
data MyBool : (value : bool) => MyBool;

type MyValue := MyInt | MyBool;

// Example 1: Literal pattern with specific min-bound
val test_literal : (v : MyValue) => number := 
  (v : MyValue) =>
  switch (v) [
    (MyInt(1) : MyValue) => 100,    // min-bound: 1, max-bound: MyValue
    (MyInt(n) : MyValue) => n,      // min-bound: MyValue, max-bound: MyValue  
    (MyBool(b) : MyValue) => if(b) { 1 } else { 0 }
  ];

// Example 2: Variable pattern covering entire type
val test_variable : (v : MyValue) => number := 
  (v : MyValue) =>
  switch (v) [
    (x : MyValue) => 42             // min-bound: MyValue, max-bound: MyValue
  ];

// Example 3: Mixed patterns for exhaustivity test
val test_mixed : (v : MyValue) => number := 
  (v : MyValue) =>
  switch (v) [
    (MyInt(n) : MyValue) => n,      // min-bound: MyInt, max-bound: MyValue
    (MyBool(b) : MyValue) => if(b) { 1 } else { 0 }  // min-bound: MyBool, max-bound: MyValue
  ];
  // Exhaustivity: MyValue <: (MyInt | MyBool) should be satisfied

val main : (input : number) => number := 
  (x : number) => test_mixed(MyInt(42));