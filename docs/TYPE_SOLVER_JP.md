# Memento型ソルバー - 現在の実装

## 概要

この文書は、Mementoプログラミング言語の制約ベース型ソルバーについて説明します。このソルバーは、多相性、合併型/交差型、部分型付け、網羅的パターンマッチングなどの高度な型システム機能を扱います。

## 型システム

### コア型

```haskell
data Type
  = TTop | TBottom          -- トップ型とボトム型
  | TNumber | TBool | TString | TNever | TUnknown  -- プリミティブ型
  | TLiteral Literal        -- リテラル型 (42, true, "hello")
  | TVar TypeVar           -- 新鮮な型変数（単一化変数）
  | TConstructor T.Text    -- 名前付きコンストラクタ（異なる基底型）  
  | TFunction Type Type    -- 関数型
  | TUnion (Set Type)      -- 合併型 (A | B)
  | TIntersection (Set Type)  -- 交差型 (A & B)
  -- 多相性サポート
  | TGeneric T.Text           -- ジェネリック型パラメータ (T, U, V)
  | TApplication Type [Type]  -- 型適用 (List<T>, Map<K,V>)
```

### 多相性サポート

- **型スキーム**: `TypeScheme [vars] type` は `forall vars. type` を表現
- **一般化**: 単相型から多相型スキームへの変換
- **具体化**: 多相値を使用する際に新鮮な型変数を生成
- **分散分析**: 共変/反変型パラメータの自動検出

### 制約言語

ソルバーは部分型制約を扱います：
```haskell
data Constraint = Subtype Type Type  -- t1 <: t2
```

## アルゴリズムの概要

型ソルバーは複数ステップの制約解決アルゴリズムに従います：

```
1. 制約分解
2. 矛盾検出  
3. 境界計算
4. 型単一化
5. 分岐分割（必要に応じて）
```

アルゴリズムはステップ1-4を以下のいずれかになるまで繰り返します：
- **成功**: すべての制約が一貫した置換で解決
- **矛盾**: 一貫性のない制約を検出
- **曖昧性**: 複数の解が存在し、分岐により処理

## 詳細なアルゴリズムステップ

### ステップ1: 制約分解

構造的規則を適用して複雑な制約をより単純な形式に分解します：

#### 合併型の分解
```
or(A, B, C) <: T  →  A <: T, B <: T, C <: T
```

#### 交差型の分解  
```
S <: and(A, B, C)  →  S <: A, S <: B, S <: C
```

#### 関数型の分解（引数において反変）
```
(A1 -> R1) <: (A2 -> R2)  →  A2 <: A1, R1 <: R2
```

#### 型適用の分解（分散を考慮）
```
F<A1, B1> <: F<A2, B2>  →  パラメータの分散に基づく制約
```

### ステップ2: 矛盾検出

即座に解決可能または矛盾する制約を識別します：

#### 検査可能な制約
- **具体型**: `number <: bool` （即座に検査可能）
- **反射性**: `x <: x` （常に真）
- **ジェネリック反射性**: `T <: T` （同じジェネリックで常に真）
- **関数型 vs 非関数型**: `(A -> B) <: number` （常に偽）

#### ジェネリック型の処理
- **同じジェネリック**: `T <: T` → 矛盾なし
- **異なるジェネリック**: `T <: U` → 潜在的な矛盾
- **ジェネリック vs 具体型**: `T <: number` → 即座の矛盾なし

### ステップ3: 境界計算

各型変数 `x` について、すべての下限と上限を収集します：

```
{lower1, lower2, ...} <: x <: {upper1, upper2, ...}
```

#### 双方向制約の保存
- **重要な修正**: 制約を削除せずにすべての制約情報を保存
- ジェネリック型境界の処理: `x <: T`, `T <: x`
- 複数の変数間の関係を維持

#### 境界の抽出
- **下限**: `T <: x` からの制約
- **上限**: `x <: T` からの制約
- **ジェネリック境界**: `TGeneric` 型を含む制約から

### ステップ4: 型単一化

収束する境界を持つ変数に対して一意の型を見つけようとします：

#### 健全な単一化ロジック
```haskell
unifyBounds :: Bounds -> Maybe Type
unifyBounds (Bounds lowers uppers) =
  case findCommonTypes lowers uppers of
    [] -> Nothing        -- 共通の型なし
    [t] -> Just t       -- 正確に一つの共通の型
    _ -> Nothing        -- 複数の共通の型 = 曖昧
```

#### 重要な健全性の修正
- **旧（非健全）**: `([t], []) -> Just t` - 任意のスーパータイプを割り当て可能
- **新（健全）**: 型が**両方**の境界に現れる場合のみ単一化
- **根拠**: 割り当てられた型がすべての制約を満たすことを保証

#### 単一化の除外
- 型変数は単一化されない（変数のまま残る）
- ジェネリック型は単一化されない（パラメータを表し、未知数ではない）

### ステップ5: 分岐分割

進展がない場合、曖昧な制約を分割します：

#### 合併型の分岐
```
x <: A | B  →  分岐1: x <: A
              分岐2: x <: B
```

#### 交差型の分岐  
```
A & B <: x  →  分岐1: A <: x
              分岐2: B <: x
```

#### ジェネリック型の分岐
- ジェネリック型での分岐をサポート
- `T <: A | B` と `A & B <: T` を処理

## 多相性の統合

### 型パラメータのバインディング
1. **宣言**: `val identity<T> : (x : T) => T`
2. **一般化**: `TypeScheme ["T"] (TFunction (TGeneric "T") (TGeneric "T"))` を作成
3. **具体化**: 使用時に `T` を新鮮な型変数で置換

### ジェネリックを使用した制約生成
- ジェネリック型 `TGeneric "T"` は部分型付けに参加
- 自動分散分析がパラメータ関係を決定
- 型適用 `List<T>` は分散に従って分解

### 分散分析
```haskell
data Variance = Covariant | Contravariant | Invariant

-- 例:
data Box<T> : (value : T) => Box        -- T は共変
data Processor<T> : (f : (T) => number) => Processor  -- T は反変
data Cell<T> : (get : () => T, set : (T) => ()) => Cell  -- T は不変
```

## パターンマッチングの統合

### 網羅性制約
型ソルバーは網羅性制約を通じてパターンマッチングと統合します：

```haskell
-- switch式に対して、制約を生成:
⋀ max-bounds <: ⋁ min-bounds

-- ここで:
-- max-bounds = すべての可能なコンストラクタ型の合併
-- min-bounds = すべてのカバーされたパターン型の合併
```

### パターン型境界
- **最大境界**: パターンがマッチすると宣言するもの (`(x : Option) => ...`)
- **最小境界**: パターンが実際にカバーするもの (`Some(_)` は `Some<T>` をカバー)
- **網羅性**: すべての可能なケースがカバーされることを保証

## エラー処理と位置報告

### 位置認識エラーメッセージ
- 制約はASTメタデータを通じてソース位置を追跡
- エラーメッセージにはファイル位置とコード範囲が含まれる
- 多相型エラーのための強化されたデバッグ

### 一般的なエラーパターン
- **パターンケースの欠落**: 網羅性制約が失敗
- **型の不一致**: 制約解決における矛盾
- **曖昧な型**: 複数の有効な解が存在
- **無限型**: 循環型制約（単一化中に検出）

## 重要な健全性プロパティ

### 1. 単一化の健全性
- **プロパティ**: 単一化は型が両方の境界に現れる場合のみ発生
- **保証**: 割り当てられた型はすべての部分型付け制約を満たす
- **防止**: プログラムセマンティクスに違反する非健全な型割り当て

### 2. 双方向制約の保存  
- **プロパティ**: `x <: y` は `x` と `y` の両方に対して境界を生成
- **保証**: すべての制約関係が解決を通じて保存される
- **防止**: 不正確な型につながる制約情報の損失

### 3. ジェネリック型の一貫性
- **プロパティ**: ジェネリック型はソルバー全体で均一に処理される
- **保証**: 多相型はパラメトリシティを維持
- **防止**: ジェネリック型変数が誤って単一化されること

## 実装アーキテクチャ

### モジュール構造
```
TypeSolver/
├── Types.hs          -- コア型定義、多相性、分散
├── Solver.hs         -- 主要な制約解決アルゴリズム  
├── ConstraintGen.hs  -- ASTからの制約生成
├── Subtype.hs        -- 部分型付けアルゴリズム
├── Normalize.hs      -- 型正規化（合併/交差）
└── Demo.hs          -- テストと例
```

### 主要なデータ構造
```haskell
-- 制約解決状態
data InferContext = InferContext
  { icVarCounter :: Int                           -- 新鮮な変数カウンタ
  , icConstraints :: ConstraintSet                -- アクティブな制約
  , icTypeEnv :: Map T.Text TypeScheme           -- 多相型環境
  , icConstructors :: Set T.Text                 -- 既知のコンストラクタ
  , icVariances :: TypeConstructorVariances     -- 分散情報
  }

-- 制約解決結果
data SolveResult
  = Success Substitution      -- 解が見つかった
  | Contradiction            -- 解が存在しない
  | Ambiguous [ConstraintSet] -- 複数の解（分岐が必要）
```

## 将来の拡張

### 計画された改善
1. **完全な分散認識分解**: 型適用分解で分散情報を使用
2. **高階多相性**: ランクN型のサポート
3. **依存型**: 配列境界などのための限定的な依存型付け
4. **エフェクト型**: 副作用追跡のためのエフェクトシステムとの統合

### 研究の方向性
1. **制約最適化**: より効率的な制約解決アルゴリズム
2. **インクリメンタル解決**: コンパイル単位間で解決済み制約を再利用
3. **エラー回復**: 修正案付きのより良いエラーメッセージ
4. **型推論デバッグ**: 視覚的な制約解決トレース

## 参考文献

この実装は以下に基づいています：
- Pierce著「Types and Programming Languages」(TAPL)
- Dolan & Mycroft著「Polymorphism, Subtyping, and Type Inference in MLsub」
- Gaster & Jones著「A Polymorphic Type System for Extensible Records and Variants」
- 現代の制約ベース型推論研究

このアルゴリズムは、パラメトリック多相性、合併/交差型、網羅的パターンマッチングなどの高度な機能をサポートしながら、健全性を維持しています。